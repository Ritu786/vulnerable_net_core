trigger:
  branches:
    include:
      - main
      - master

# optional PR validation
pr:
  branches:
    include:
      - main
      - master

variables:
- group: blackduck-secrets
- name: buildConfiguration
  value: 'Release'
- name: projectName
  value: 'VulnerableNetCoreDemo'

stages:
# 1) Build & Test on Windows (coverity-win)
- stage: Build
  displayName: Build & Test (.NET)
  jobs:
  - job: build_dotnet
    displayName: Build .NET
    pool:
      name: coverity-win
    steps:
    - checkout: self
    - task: UseDotNet@2
      inputs:
        packageType: 'sdk'
        version: '8.x'
    - task: DotNetCoreCLI@2
      displayName: Restore
      inputs:
        command: 'restore'
        projects: '**/*.sln'
    - task: DotNetCoreCLI@2
      displayName: Build
      inputs:
        command: 'build'
        projects: '**/*.sln'
        arguments: '--configuration $(buildConfiguration)'
    - task: DotNetCoreCLI@2
      displayName: Test
      inputs:
        command: 'test'
        projects: '**/*Tests/*.csproj'
        arguments: '--configuration $(buildConfiguration) --no-build'

# 2) Coverity SAST on Windows
- stage: Coverity
  displayName: Coverity SAST
  dependsOn: Build
  jobs:
  - job: coverity_sast
    displayName: Coverity SAST
    pool:
      name: coverity-win
    steps:
    - checkout: self

    # ensure dotnet is there for fallback
    - task: UseDotNet@2
      inputs:
        packageType: 'sdk'
        version: '8.x'

    - task: DownloadSecureFile@1
      name: covAuth
      inputs:
        secureFile: 'auth-key.txt'

    - powershell: |
        $ErrorActionPreference = 'Stop'

        # Add Coverity bin to PATH
        $covBin = "C:\Program Files\Coverity\cov-analysis-win64-2025.6.0\bin"
        if (Test-Path $covBin) { $env:PATH = "$covBin;$env:PATH" } else { throw "Coverity bin not found at $covBin" }

        # Try to put MSBuild on PATH quickly (handles most installs)
        $msb64 = "C:\BuildTools\MSBuild\Current\Bin\amd64"
        $msb32 = "C:\BuildTools\MSBuild\Current\Bin"
        if (Test-Path $msb64) { $env:PATH = "$msb64;$env:PATH" }
        if (Test-Path $msb32) { $env:PATH = "$msb32;$env:PATH" }

        # Find MSBuild.exe via vswhere (most reliable)
        $vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
        $msbuild = $null
        if (Test-Path $vswhere) {
          $msbuild = & $vswhere -latest -products * -requires Microsoft.Component.MSBuild -find "MSBuild\**\Bin\amd64\MSBuild.exe" | Select-Object -First 1
          if (-not $msbuild) {
            $msbuild = & $vswhere -latest -products * -requires Microsoft.Component.MSBuild -find "MSBuild\**\Bin\MSBuild.exe" | Select-Object -First 1
          }
        }

        # Show what we've got
        Write-Host "PATH (truncated): " + ($env:PATH.Split(';') | Select-Object -First 8 | ForEach-Object { $_ }) -join ';'
        if ($msbuild) {
          & "$msbuild" -version
        } else {
          Write-Warning "vswhere did not find MSBuild.exe; will try 'msbuild' from PATH or fall back to 'dotnet msbuild'."
        }

        # Pick solution
        $sln = Get-ChildItem -Path "$(Build.SourcesDirectory)" -Filter *.sln -Recurse | Select-Object -First 1
        if (-not $sln) { throw "No .sln found under $(Build.SourcesDirectory)" }
        Write-Host "Using solution: $($sln.FullName)"

        # --- Capture build with Coverity ---
        if ($msbuild -and (Test-Path $msbuild)) {
          Write-Host "Using MSBuild at: $msbuild"
          cov-build --dir cov-int "`"$msbuild`"" "`"$($sln.FullName)`"" /t:Rebuild /p:Configuration=$(buildConfiguration)
        } else {
          # try PATH msbuild first
          $msbCmd = Get-Command msbuild -ErrorAction SilentlyContinue
          if ($msbCmd) {
            Write-Host "Using msbuild from PATH: $($msbCmd.Source)"
            cov-build --dir cov-int msbuild "`"$($sln.FullName)`"" /t:Rebuild /p:Configuration=$(buildConfiguration)
          } else {
            # final fallback: dotnet msbuild
            Write-Warning "Falling back to 'dotnet msbuild'."
            & dotnet --info
            cov-build --dir cov-int dotnet msbuild "`"$($sln.FullName)`"" /t:Rebuild /p:Configuration=$(buildConfiguration)
          }
        }

        # Analyze & publish
        cov-analyze --dir cov-int --all
        cov-format-errors --dir cov-int --html-output cov-html
        cov-commit-defects --dir cov-int `
          --url "$(COVERITY_URL)" `
          --stream "$(COVERITY_STREAM)" `
          --auth-key-file "$(covAuth.secureFilePath)" `
          --description "ADO $(Build.BuildNumber) $(Build.SourceVersion)" `
          --on-new-cert trust
      displayName: Capture, Analyze & Commit

    - task: PublishBuildArtifacts@1
      displayName: Publish Coverity HTML
      inputs:
        PathtoPublish: 'cov-html'
        ArtifactName: 'coverity-report'


# 3) Black Duck SCA on Linux
- stage: BlackDuck
  displayName: Black Duck SCA
  dependsOn: Coverity
  jobs:
  - job: bd_scan
    displayName: Detect Scan
    pool:
      name: blackduck-linux
    steps:
    - checkout: self
    - bash: |
        set -e
        curl -s -L https://detect.synopsys.com/detect9.sh -o detect.sh
        chmod +x detect.sh
        ./detect.sh \
          --blackduck.url="$(BD_URL)" \
          --blackduck.api.token="$(BD_API_TOKEN)" \
          --blackduck.trust.cert=true \
          --detect.project.name="@HooliCorp/vulnerable_net_core" \
          --detect.project.version.name="$(Build.SourceVersion)" \
          --detect.policy.check=true \
          --detect.cleanup=true \
          --detect.timeout=1200
      displayName: Black Duck Detect (SCA)
